第二周题解：
十题（模拟做起来好烦啊，一个小错误要看好久，费时费力，而且感觉没学到东西，crying。。。）
/***********************************UVA112*************************************/
/*居然可能是负数。。。括号的话很自然的想到用类似于栈的机制*/
/*一开始我想不出来怎么去输入，看到题解是用一个left和right的过程来模拟栈的长度，只要栈空，则说明输入结束了*/
/*这一题还有个特别好的地方，就是一开始的边界进入的方式，非常巧妙*/
/*最后是，这个题目用四个字符循环的方法来判断是否到达叶子节点，也是非常巧妙的方法*/
//代码：
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
int des,l,r,level,sum;
int tree[4010];
char ch[4];
int main(){
    char c;
	while(scanf("%d",&des)!=EOF){
        memset(tree,0,sizeof(tree));
        memset(ch,' ',sizeof(ch));
        level=0;
        sum=0;
        l=r=0;
        int fu=1;
        bool flag=0;
        bool biaoji=1;
        bool re;
        while(l!=r||biaoji){
            scanf("%c",&c);
            if((c>='0'&&c<='9')||c=='('||c==')'||c=='-'){
                if((c>='0'&&c<='9')||c=='-'){
                    if(c>='0'&&c<='9')
                        tree[level]=10*tree[level]+c-'0';
                    else fu=-1;
                    re=1;
                }
                else if(re){
                    tree[level]*=fu;
                    sum+=tree[level];
                    re=0;
                    level++;
                    fu=1;
                }
                else ;
                ch[3]=ch[2];
                ch[2]=ch[1];
                ch[1]=ch[0];
                ch[0]=c;
                if(ch[3]=='('&&ch[2]==')'&&ch[1]=='('&&ch[0]==')'){
                    if(sum==des) flag=1;
                    memset(ch,' ',sizeof(ch));
                }
                else if(ch[1]!='('&&ch[0]==')'){
                    sum-=tree[level-1];
                    tree[--level]=0;
                }
                if(c=='(')
                    l++;
                else if(c==')')
                    r++;
                if(l!=r) biaoji=0;
            }
        }
        if(flag) puts("yes");
        else puts("no");
	}
	return 0;
}
/*******************************************************************************/
/***********************************   UVA127   *************************************/
/*模拟*/
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <stack>
#include <vector>
using namespace std;
struct Card{
    char c;
    char color;
};
vector<stack<Card> >p;

bool cmp(Card a,Card b){
    if(a.c==b.c)
        return 1;
    if(a.color==b.color)
        return 1;
    return 0;
}
void solve(){
    while(1){
        int i;
        for(i=0;i!=p.size();i++){
            if(i>=3&&cmp(p[i].top(),p[i-3].top())){
                p[i-3].push(p[i].top());
                p[i].pop();
                break;
            }
            if(i>=1&&cmp(p[i].top(),p[i-1].top())){
                p[i-1].push(p[i].top());
                p[i].pop();
                break;
            }
        }
        if(i==p.size()) break;
        else if(p[i].empty()){
            p.erase(p.begin()+i);
        }
    }
    cout<<p.size();
    if(p.size()==1) cout<<" pile remaining:";
    else cout<<" piles remaining:";
    for(int i=0;i<p.size();i++)
        cout<<" "<<p[i].size();
    cout<<endl;
}
int main(){
    string str;
    int cnt(0),i=0,k=0;
    p.clear();
    stack<Card> s;
    while(!s.empty()) s.pop();
    Card card;
	while(1){
        cin>>str;
        cnt++;
        if(str[0]=='#') break;
        if(cnt==52){
            card.c=str[0];
            card.color=str[1];
            s.push(card);
            p.push_back(s);
            s.pop();//WA一发就是这个地方，因为我52的时候那个没有压进去，前面的忘了写了
            solve();
            while(!s.empty()) s.pop();
            cnt=0;
            p.clear();
        }
        else{
            card.c=str[0];
            card.color=str[1];
            s.push(card);
            p.push_back(s);
            s.pop();
        }
	}
	return 0;
}
/*********************************************************************************/
/**********************************  UVA101  ************************************/
/*这个题目做了几乎一天。。。。一开始做了一个非常烦的思路，写了四个fun来对应四种操作，问题是
我中间用了复制粘贴。。。结果我第一部分有两个问题，所以一直RE+WA。。。后来看题解发现原来可以抽象
成两种基本操作。。。。啊啊啊啊啊啊啊，亏我还是学C++的。。。cry。。。*/
//代码（参考了题解，有一个.2是我的错误代码，能麻烦大家看一下么？）：
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
int loc[30];//loc[i]记录i在那个位置，很巧妙的方法
int shu[30][30];//一个栈其实是
int top[25];//栈的个数
int buffer[30];
void qingchu(int a){
    int tmp;
    int loca=loc[a];
    while(shu[loca][top[loca]]!=a){//找到这个a
        tmp=shu[loca][top[loca]--];
        loc[tmp]=tmp;//回去，所以自然是这个位置
        shu[tmp][++top[tmp]]=tmp;//原来那个栈要更新
    }
}
void yidong(int a,int b){
    int loca,locb;
    loca=loc[a];
    locb=loc[b];
    int k=-1;//复制到一个缓冲数组里面
    while(shu[loca][top[loca]]!=a)
        buffer[++k]=shu[loca][top[loca]--];
    loc[a]=locb;//所有的位置都是locb
    shu[locb][++top[locb]]=a;
    top[loca]--;
    while(k>=0){
        loc[buffer[k]]=locb;//将数据加到上面，位置指向locb
        shu[locb][++top[locb]]=buffer[k--];
    }
}
int main(){
    string str1,str2;
    int n;
    int a,b;
    while(scanf("%d",&n)!=EOF){
        memset(top,0,sizeof(top));
        for(int i=0;i<n;i++)
        {
            shu[i][0]=i;
            loc[i]=i;
            top[i]=0;
        }
        while(cin>>str1){
            if(str1=="quit") break;
            cin>>a>>str2>>b;
            if(loc[a]==loc[b]||a==b) {
                continue;
            }
			//以下四步就是这样的情况
            if(str1=="move"&&str2=="onto"){
                qingchu(a);
                qingchu(b);
                yidong(a,b);
            }
            else if(str1=="move"&&str2=="over"){
                qingchu(a);
                yidong(a,b);
            }
            else if(str1=="pile"&&str2=="onto"){
                qingchu(b);
                yidong(a,b);
            }
            else if(str1=="pile"&&str2=="over"){
                yidong(a,b);
            }
            else;
        }
        for ( int i = 0 ; i < n ; ++ i ) {
            printf("%d:",i);
            int k=0;
            while(k<=top[i])
                printf(" %d",shu[i][k++]);//注意空格
            printf("\n");
        }
    }
	return 0;
}
/********************************************************************************/
/**********************************  UVA340  ************************************/
/*一个用数组的技巧*/
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
int a[1010],b[1010];
int aux[15],bux[15],dux[15];
int main(){
	int n,nc(1);
	while(scanf("%d",&n)!=EOF){
        if(n==0) break;
        memset(a,0,sizeof(a));
        printf("Game %d:\n",nc++);
        memset(aux,0,sizeof(aux));
        memset(dux,0,sizeof(dux));
        for(int i=0;i<n;i++)
        {
            scanf("%d",&a[i]);
            aux[a[i]]++;
            dux[a[i]]++;
        }
        while(1){
            memset(bux,0,sizeof(bux));
            for(int i=0;i<10;i++){
                aux[i]=dux[i];
            }
            for(int i=0;i<n;i++)
            {
                scanf("%d",&b[i]);
                bux[b[i]]++;
            }
            if(bux[0]==n) break;
            int ans1(0),ans2(0);
            for(int i=0;i<n;i++){
                if(a[i]==b[i])
                {
                    ans1++;
                    aux[a[i]]--;
                    bux[b[i]]--;
                }
            }
            for(int i=0;i<10;i++){
                ans2+=min(aux[i],bux[i]);
                /*cout<<"a: "<<aux[i]<<" || b: "<<bux[i]<<" duan "<<endl;
                cout<<ans2<<endl;*/
            }
            printf("    (%d,%d)\n",ans1,ans2);
        }
	}
	return 0;
}
/*******************************************************************************/
/**********************************UVA10420*************************************/
/*复习一下迭代器的用法以及读取空格的技巧的*/
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <map>
#include <string>
using namespace std;
map<string,int>mp;
int main(){
	int T;
	string str;
	scanf("%d",&T);
	getchar();
	while(T--){
        cin>>str;
        //cout<<str<<endl;
        getchar();
        mp[str]++;
        getline(cin,str);
	}
	map<string ,int>::iterator it;
	for(it=mp.begin();it!=mp.end();it++)
        cout<<it->first<<" "<<it->second<<endl;//迭代器的用法
	return 0;
}
/*********************************************************************************/
/*******************************  lightoj  1113  *********************************/
/*由于在一个回退之后还是还会继续前进到这个网页，即在我以此操作之后必须要有方法去多次回到
这个网站，所以考虑数据结构，双栈模拟*/
//代码：
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
#include <cmath>
#include <stack>
#include <string>
using namespace std;
stack<string> s1;
stack<string> s2;
int main()
{
    string str,du;
    int T,nc=1;
    scanf("%d",&T);
    while(T--)
    {
        while(!s2.empty())
            s2.pop();
        while(!s1.empty())
            s1.pop();//清空栈的操作
        s1.push("http://www.lightoj.com/");//初始的网站
        printf("Case %d:\n",nc++);//一开始以为分步输出是不行的，但是后来发现还是可以的，如果不是分步输出，要用队列或者是数组来存放
        while(1)
        {
            cin>>str;
            if(str[0]=='Q')
                break;
            if(str[0]=='B')
            {
                if(!s1.empty())
                {
                    s2.push(s1.top());
                    s1.pop();
                    if(s1.empty())//空了，说明退不回去了
                    {
                        s1.push(s2.top());
                        s2.pop();
                        cout<<"Ignored"<<endl;
                    }
                    else
                        cout<<s1.top()<<endl;
                }
            }
            if(str[0]=='F')
            {
                if(!s2.empty())
                {
                    s1.push(s2.top());
                    s2.pop();
                    cout<<s1.top()<<endl;
                }
                else
                    cout<<"Ignored"<<endl;
            }
            if(str[0]=='V')
            {
                cin>>du;
                s1.push(du);
                while(!s2.empty())
                    s2.pop();
                cout<<du<<endl;
            }
        }
    }
    return 0;
}
/***************************************************************************************/
/*******************************  lightoj 1212  ****************************************/
/*很水的一个双向队列的题目，判空，左边就是back，右边就是front，直接模拟*/
//代码：
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <deque>
using namespace std;
deque <int> dq;
string str;
int main(){
	int T,nc(1);
	scanf("%d",&T);
	int full,n,d;
	while(T--){
        scanf("%d%d",&full,&n);
        printf("Case %d:\n",nc++);
        dq.clear();
        while(n--){
            cin>>str;
            if(str=="pushLeft"){
                cin>>d;
                if(dq.size()==full)
                    cout<<"The queue is full"<<endl;
                else{
                    dq.push_back(d);
                    cout<<"Pushed in left: "<<d<<endl;
                }
            }
            if(str=="pushRight"){
                cin>>d;
                if(dq.size()==full)
                    cout<<"The queue is full"<<endl;
                else{
                    dq.push_front(d);
                    cout<<"Pushed in right: "<<d<<endl;
                }
            }
            if(str=="popLeft"){
                if(dq.size()==0)
                    cout<<"The queue is empty"<<endl;
                else{
                    d=dq.back();
                    cout<<"Popped from left: "<<d<<endl;
                    dq.pop_back();
                }
            }
            if(str=="popRight"){
                if(dq.size()==0)
                    cout<<"The queue is empty"<<endl;
                else{
                    d=dq.front();
                    cout<<"Popped from right: "<<d<<endl;
                    dq.pop_front();
                }
            }
        }
	}
	return 0;
}
/******************************************************************************************/
/**************************** lightoj1303  ***********************************************/
/*一开始把题目看错了，忘记有一个下来会去结尾这一说了，然后不知道应该怎么模拟，准备推公式，发现
智商不太够，所以。。。后来请教了伟佳巨巨，做出来了*/
//代码（这一题我问的伟佳巨巨的思路，所以注释写详细一点）：
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <deque>
#include <queue>
#include <list>
using namespace std;
deque<int>dq;
deque<int>::iterator it;
const int inf=0xfffffff;
bool vis[22][22];
int mx[22];
int main(){
	int T;
	int n,m,nc(1);
	scanf("%d",&T);
	while(T--){
        scanf("%d%d",&n,&m);
        int ans=0,k=0,tmp;
        bool flag;
        dq.clear();
        memset(mx,inf,sizeof(mx));
        memset(vis,false,sizeof(vis));
        for(int i=0;i<n;i++) dq.push_back(i);//这是对应于在下面的人的那个队列，用i来表示第i个人，从0开始的
        while(1){//每次去一个座位
            ans++;//这是第几次有座位来了
            flag=1;//判断标记，下面用到
            if(mx[k]>=0){//如果这个座位原来是有人的
                dq.push_back(mx[k]);//下来，插到队尾
                mx[k]=-1;
            }
            for(it=dq.begin();it!=dq.end();++it){//找到一个没有坐过这个座位的人来做
                tmp=(*it);//迭代器的用法
                if(!vis[tmp][k]){//如果这个是没有上去过的，那么就上去
                    mx[k]=tmp;
                    vis[tmp][k]=1;
                    dq.erase(it);
                    break;
                }
            }
			/*这是一个判重的模块*/
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(!vis[i][j])//所有人做过所有的座位
                    {
                        flag=0;
                        break;
                    }
                }
                if(!flag) break;//这一步可以节约时间
            }
            if(flag) break;
            k=(k+1)%m;//下一个座位号，有循环，所以取余
        }
        ans+=m;//最后所有人要都下来
        printf("Case %d: %d\n", nc++, ans*5);//先统计次数，*5
	}
	return 0;
}
/***********************************************************************************/
/************************** lightoj1048  *********************************************/
/*最小化最大值，最大化最小值，显然用二分。一开始忘了我是用mid作为最后结果，所以在做的时候出现了
一点问题，一开始准备在每一次的judge中直接存储结果的，结果传入数据是不对的，而且不可能是我想要的那个
最后干脆换了思路，后来想想貌似节约了时间*/
//代码：
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
#include <vector>
using namespace std;

const int MAXN=10010;
int dis[MAXN];
int cnt(0);
int n,k;
bool judge(int mid){
    int i(0),j(0);
    int sum=0;
    cnt=0;
    //cout<<"chuanru : "<<mid<<endl;
    for(i=1;i<=n;i++){
        if(dis[i]>mid) return 0;
        if(sum+dis[i]<=mid){
            sum+=dis[i];
        }
        else{
            sum=dis[i];
            cnt++;
        }
    }
    return cnt<=k;
}
int main(){
	int T,nc(1);
	scanf("%d",&T);
	while(T--){
        //memset(dis,0,sizeof(dis));//这题坑啊，卡memset的时间，把我TLE的。。。
        scanf("%d%d",&n,&k);
        int i;
        n++;
        int left(0),right(0),res;
        for(i=1;i<=n;i++){
            scanf("%d",&dis[i]);
            right+=dis[i];//这个东西取0和这个其实是差不多的，多算几次而已
            left=max(left,dis[i]);//这个是必须的
        }
        while(left<=right){
            int mid=(left+right)/2;
            if(judge(mid)){
                right=mid-1;
                res=mid;//先求出结果
            }
            else{
                left=mid+1;
            }
        }
        printf("Case %d: %d\n",nc++,res);
        int sum=0;
        int num(0);
        for(i=1;i<=n;i++){//再输出方案
            if(sum+dis[i]>res||n-i<k-num){
                printf("%d\n",sum);
                sum=dis[i];
                num++;
            }
            else
                sum+=dis[i];
        }
        printf("%d\n",sum);
	}
	return 0;
}
/*************************************************************************************/
/**************************  lightoj1056  *******************************************/
/*lightoj上这个题目是二分。。。然而，这应该算是一个几何的题目，很水*/
//代码：
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const double pi=acos(-1);
int main(){
	int T,nc(1);
	double a,b,ans1,ans2;
	scanf("%d",&T);
	//cout<<T<<endl;
	while(T--){
        char c;
        cin>>a;
        getchar();
        getchar();
        getchar();
        cin>>b;
        //cout<<a<<" "<<b<<endl;
        double degree=atan(b/a);
        //cout<<a<<" "<<b<<endl;
        double r=100.0/(degree+cos(degree));
        ans1=2*r*cos(degree);
        ans2=2*r*sin(degree);
        printf("Case %d: %.10lf %.10lf\n",nc++,ans1,ans2);
	}
	return 0;
}
/******************************************************************************/
